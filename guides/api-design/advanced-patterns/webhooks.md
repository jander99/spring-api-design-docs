# Webhooks Design Guide

> **ðŸ“– Reading Guide**
> 
> **â±ï¸ Reading Time:** 10 minutes | **ðŸŸ¡ Level:** Intermediate
> 
> **ðŸ“‹ Prerequisites:** HTTP fundamentals, Security basics
> **ðŸŽ¯ Key Topics:** Event-driven architecture, Security, Reliability
> 
> **ðŸ“Š Complexity:** Grade 14 â€¢ Intermediate technical density â€¢ Difficult

## Overview

Webhooks are a "push" mechanism that allows an API to notify external systems about events in real-time. Instead of a client repeatedly polling an API to check for updates, the API sends an HTTP POST request to a URL provided by the client when a specific event occurs.

Webhooks are essential for:
- **Real-time Notifications**: Immediate updates for order status, payments, or system alerts.
- **Asynchronous Workflows**: Triggering downstream processes after a long-running task completes.
- **System Integration**: Syncing data between decoupled services without constant polling.

## Webhook Registration Patterns

To receive webhooks, clients must register a subscription. This is typically managed through a dedicated resource in your API.

### Webhook Subscription Model

The subscription resource should capture where to send events and which events the client is interested in.

| Field | Description |
|-------|-------------|
| `url` | The HTTPS endpoint where the server will send POST requests. |
| `events` | A list of event types to subscribe to (e.g., `order.created`, `user.updated`). |
| `secret` | A shared secret used for signing payloads (generated by the server). |
| `status` | Current state of the webhook (`active`, `paused`, `disabled`). |
| `description` | Optional user-defined label for the webhook. |

### Registration Example

```http
POST /v1/webhooks HTTP/1.1
Content-Type: application/json

{
  "url": "https://client-app.example.com/webhooks/orders",
  "events": ["order.created", "order.fulfilled"],
  "description": "Production order sync"
}

HTTP/1.1 201 Created
Location: /v1/webhooks/wh_12345
Content-Type: application/json

{
  "id": "wh_12345",
  "url": "https://client-app.example.com/webhooks/orders",
  "events": ["order.created", "order.fulfilled"],
  "secret": "whsec_p8Xz9...",
  "status": "active",
  "createdAt": "2024-01-15T10:00:00Z"
}
```

### URL Verification (Challenge-Response)

To prevent users from subscribing to URLs they don't own, implement a verification step.
1. **Synchronous**: Send a GET request with a `challenge` parameter to the URL during registration. The client must return the challenge.
2. **Asynchronous**: Register the webhook as `pending`, send a verification event, and wait for the client to confirm through a separate API call.

## Event Schema and Versioning

A consistent event structure helps consumers process webhooks reliably.

### The Event Envelope

Every webhook payload should follow a standard envelope format:

```json
{
  "id": "evt_abc123",
  "type": "order.created",
  "version": "1.0",
  "createdAt": "2024-01-15T10:30:00Z",
  "data": {
    "orderId": "ord_789",
    "status": "pending",
    "total": 99.99
  }
}
```

- **`id`**: A unique identifier for the event (used for deduplication).
- **`type`**: The event category using dot notation (`resource.action`).
- **`version`**: The schema version of the payload.
- **`data`**: The actual resource representation or delta.

### Schema Evolution

- **Backward Compatibility**: Avoid removing fields or changing types in the `data` object.
- **Versioning**: If breaking changes are necessary, increment the version in the envelope or use a different endpoint/header.
- **Content Negotiation**: Allow clients to specify which version they want to receive during registration.

## Security Standards

Since webhook endpoints are public, they must be secured to prevent unauthorized or spoofed requests.

### HMAC-SHA256 Signatures

The standard way to secure webhooks is by signing the payload with a shared secret using HMAC-SHA256.

1. **Generation**: The server calculates a signature of the raw request body using the shared secret.
2. **Transmission**: The signature is sent in a header (e.g., `X-Webhook-Signature`).
3. **Verification**: The client performs the same calculation and compares results.

#### Replay Attack Protection

Include a timestamp in the signature calculation and send it in a header (`X-Webhook-Timestamp`). The client should reject requests where the timestamp is too old (e.g., > 5 minutes).

**Signature Header Example:**
`X-Webhook-Signature: t=1234567890,v1=abc123def456...`

### Security Best Practices

- **HTTPS Only**: Only allow registration of `https://` URLs.
- **Secret Rotation**: Provide an API or UI for clients to rotate their webhook secrets.
- **IP Whitelisting**: Optionally provide a list of IP addresses that webhook requests will originate from.
- **mTLS**: For high-security environments, use Mutual TLS to verify both client and server identities.

## Reliability and Delivery

Network issues are common. Your webhook system must be resilient to failures.

### Retry Policy

Implement an exponential backoff strategy with jitter for failed deliveries (responses other than 2xx).

**Example Retry Schedule:**
- Attempt 1: Immediate
- Attempt 2: 5 minutes later
- Attempt 3: 30 minutes later
- Attempt 4: 2 hours later
- Attempt 5: 24 hours later (Final)

### Timeouts and Circuit Breakers

- **Timeouts**: Set a strict timeout for webhook requests (e.g., 5-10 seconds).
- **Circuit Breaker**: If a client's endpoint fails consistently for a long period (e.g., 24 hours), automatically pause the subscription and notify the user.

### Dead Letter Handling (DLQ)

When all retry attempts fail, move the event to a Dead Letter Queue.
- **Manual Retry**: Allow users to trigger a manual retry of failed events via the API or dashboard.
- **Alerting**: Notify the client when a webhook subscription is automatically disabled due to persistent failures.
- **Inspection**: Provide logs showing the request sent and the error response received.

## Idempotency and Deduplication

In distributed systems, "exactly-once" delivery is extremely difficult. Most webhook systems guarantee "at-least-once" delivery, meaning a client might receive the same event twice.

**Consumer Requirements:**
1. **Deduplication**: Store the `id` of processed events. If a new request arrives with a known `id`, acknowledge it but do not process it again.
2. **Idempotency Keys**: If the webhook triggers a downstream API call, pass an idempotency key to prevent duplicate side effects.

## Consumer Implementation Best Practices

To ensure a smooth integration, webhook consumers should follow these patterns:

1. **Acknowledge Quickly**: Return a `200 OK` or `202 Accepted` immediately after receiving the request. Do not perform heavy processing synchronously.
2. **Process in Background**: Use a message queue or background job system to process the payload asynchronously.
3. **Handle Concurrency**: Be prepared for multiple webhooks arriving simultaneously or out of order.
4. **Avoid 5xx Responses**: If your system is temporarily overwhelmed, return `429 Too Many Requests` or `503 Service Unavailable` so the producer knows to retry later.

## Example HTTP Delivery

```http
POST /webhooks/orders HTTP/1.1
Host: client-app.example.com
Content-Type: application/json
X-Webhook-ID: evt_abc123
X-Webhook-Timestamp: 1705314600
X-Webhook-Signature: v1=7d8e9f...
User-Agent: Webhook-Service/1.0

{
  "id": "evt_abc123",
  "type": "order.created",
  "version": "1.0",
  "createdAt": "2024-01-15T10:30:00Z",
  "data": {
    "orderId": "ord_789",
    "customer": "cust_456",
    "total": 99.99
  }
}

HTTP/1.1 200 OK
```

## Related Documentation

- [Asynchronous Operations](./async-operations.md): How webhooks fit into async status patterns.
- [Event-Driven Architecture](../../architecture/event-driven-architecture.md): High-level patterns for event systems.
- [Security Standards](../security/security-standards.md): General API security principles.
- [Idempotency and Safety](../foundations/idempotency-and-safety.md): Principles of safe retries and deduplication.
