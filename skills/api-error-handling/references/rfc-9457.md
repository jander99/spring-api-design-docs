# RFC 9457 Problem Details

RFC 9457 defines the standard format for expressing errors in HTTP APIs. It obsoletes RFC 7807, consolidating best practices and clarifications. This reference covers the specification details, extensions, and advanced usage patterns.

## Standard Fields

### Required Understanding

All fields in RFC 9457 are technically optional, but best practice recommends including:

| Field | Type | Description |
|-------|------|-------------|
| `type` | URI | Identifies the problem type. Defaults to `about:blank` if omitted. |
| `title` | string | Short, human-readable summary. Should be consistent for each `type`. |
| `status` | integer | HTTP status code. Included for convenience (matches response status). |
| `detail` | string | Human-readable explanation specific to this occurrence. |
| `instance` | URI | Identifies this specific problem occurrence (usually the request path). |

### Field Details

**`type` field:**
- Must be a URI that identifies the problem type
- Use `about:blank` for generic problems without a specific type
- Should be dereferenceable (ideally returns documentation)
- Remains stable across API versions

```json
"type": "https://api.example.com/problems/insufficient-funds"
```

**`title` field:**
- Human-readable, should not change between occurrences
- Localizable but typically English
- Matches the problem `type`, not the specific occurrence

```json
"title": "Insufficient Funds"
```

**`detail` field:**
- Explains this specific occurrence
- May include dynamic values
- Should be actionable when possible

```json
"detail": "Your account balance of $10.00 is insufficient for this $25.00 purchase"
```

**`instance` field:**
- URI reference to this specific occurrence
- Typically the request path
- Can be used for log correlation

```json
"instance": "/v1/payments/pay-123"
```

## Content-Type

Always use the correct media type:

```http
Content-Type: application/problem+json
```

For XML APIs (less common):
```http
Content-Type: application/problem+xml
```

## Extension Fields

RFC 7807 allows custom extension fields. Common patterns:

### Validation Errors Extension

```json
{
  "type": "https://api.example.com/problems/validation-error",
  "title": "Validation Error",
  "status": 400,
  "detail": "Request validation failed",
  "instance": "/v1/users",
  "errors": [
    {
      "field": "email",
      "code": "INVALID_FORMAT",
      "message": "Must be a valid email address",
      "value": "not-an-email"
    }
  ]
}
```

### Request Correlation Extension

```json
{
  "type": "https://api.example.com/problems/internal-error",
  "title": "Internal Server Error",
  "status": 500,
  "detail": "An unexpected error occurred",
  "instance": "/v1/orders",
  "requestId": "req-550e8400-e29b-41d4",
  "timestamp": "2024-01-15T10:30:00Z"
}
```

### Domain-Specific Extension

```json
{
  "type": "https://api.example.com/problems/order-limit-exceeded",
  "title": "Order Limit Exceeded",
  "status": 400,
  "detail": "Cannot place more than 10 orders per day",
  "instance": "/v1/orders",
  "ordersToday": 10,
  "dailyLimit": 10,
  "resetsAt": "2024-01-16T00:00:00Z"
}
```

### Rate Limiting Extension

```json
{
  "type": "https://api.example.com/problems/rate-limit-exceeded",
  "title": "Rate Limit Exceeded",
  "status": 429,
  "detail": "Too many requests",
  "instance": "/v1/orders",
  "limit": 100,
  "remaining": 0,
  "reset": 1705312260,
  "retryAfter": 60
}
```

## Problem Type Registry

Maintain a registry of problem types for your API:

### Standard HTTP Problems

| Type URI | Title | Status | Usage |
|----------|-------|--------|-------|
| `about:blank` | (varies) | (varies) | Generic problems, no specific type |
| `.../validation-error` | Validation Error | 400 | Field validation failures |
| `.../authentication-required` | Authentication Required | 401 | Missing/invalid credentials |
| `.../access-denied` | Access Denied | 403 | Insufficient permissions |
| `.../resource-not-found` | Resource Not Found | 404 | Entity doesn't exist |
| `.../method-not-allowed` | Method Not Allowed | 405 | Wrong HTTP method |
| `.../conflict` | Conflict | 409 | State conflict |
| `.../rate-limit-exceeded` | Rate Limit Exceeded | 429 | Too many requests |
| `.../internal-error` | Internal Server Error | 500 | Server errors |

### Domain-Specific Problems

Define problem types for business rules:

```
https://api.example.com/problems/
├── orders/
│   ├── cannot-cancel-shipped    # 409 - Order already shipped
│   ├── insufficient-inventory   # 400 - Not enough stock
│   └── payment-required         # 402 - Payment needed
├── payments/
│   ├── card-declined           # 400 - Card was declined
│   ├── insufficient-funds      # 400 - Not enough balance
│   └── expired-card            # 400 - Card has expired
└── users/
    ├── email-already-exists    # 409 - Duplicate email
    └── account-suspended       # 403 - Account is suspended
```

## Internationalization

For multi-language support, consider these patterns:

### Option 1: Accept-Language Header

Client sends preferred language:
```http
Accept-Language: es-ES, es;q=0.9, en;q=0.8
```

Server responds in requested language:
```json
{
  "type": "https://api.example.com/problems/validation-error",
  "title": "Error de Validación",
  "detail": "El campo email no es válido"
}
```

### Option 2: Localized Messages Extension

Include multiple translations:
```json
{
  "type": "https://api.example.com/problems/validation-error",
  "title": "Validation Error",
  "detail": "The email field is invalid",
  "errors": [
    {
      "field": "email",
      "code": "INVALID_FORMAT",
      "message": "Must be a valid email",
      "localizedMessages": {
        "en": "Must be a valid email",
        "es": "Debe ser un email válido",
        "fr": "Doit être un email valide"
      }
    }
  ]
}
```

## Content Negotiation

Handle clients that don't accept `application/problem+json`:

```
Accept: application/json
```

Response can still use RFC 9457 structure with `application/json`:

```http
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "type": "https://api.example.com/problems/validation-error",
  "title": "Validation Error",
  "status": 400,
  "detail": "Request validation failed"
}
```

## Security Considerations

### Do Not Expose

Never include in error responses:
- Stack traces
- Database error messages
- Internal file paths
- SQL queries
- Server configuration details
- Dependency versions

### Safe Error Messages

**Unsafe (exposes internals):**
```json
{
  "detail": "SQLSTATE[23000]: Integrity constraint violation: 1062 Duplicate entry 'john@example.com' for key 'users.email'"
}
```

**Safe (actionable, no internals):**
```json
{
  "detail": "A user with this email address already exists",
  "type": "https://api.example.com/problems/duplicate-email"
}
```

### Production vs Development

In development, you may include more detail:
```json
{
  "type": "https://api.example.com/problems/internal-error",
  "title": "Internal Server Error",
  "status": 500,
  "detail": "NullPointerException in OrderService.processOrder",
  "debugInfo": {
    "exception": "java.lang.NullPointerException",
    "location": "OrderService.java:142"
  }
}
```

In production, sanitize:
```json
{
  "type": "https://api.example.com/problems/internal-error",
  "title": "Internal Server Error",
  "status": 500,
  "detail": "An unexpected error occurred. Please try again or contact support.",
  "requestId": "req-550e8400"
}
```

## Streaming API Errors

For streaming responses (SSE, NDJSON), errors mid-stream use the same format:

```
data: {"id": 1, "name": "Item 1"}
data: {"id": 2, "name": "Item 2"}
data: {"type": "https://api.example.com/problems/stream-error", "title": "Stream Error", "status": 500, "detail": "Connection to database lost"}
```

The client should check each message for the presence of `type` to detect errors.
